package reports

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-pdf/fpdf"
)

const (
	pdfMarginLeft   = 15.0
	pdfMarginTop    = 15.0
	pdfMarginRight  = 15.0
	pdfPageWidth    = 210.0 // A4
	pdfContentWidth = pdfPageWidth - pdfMarginLeft - pdfMarginRight
)

// PDFFilename returns the standard filename for a report PDF
func PDFFilename(periodType string, generatedAt time.Time) string {
	return fmt.Sprintf("%s-%s.pdf", periodType, generatedAt.Format("2006-01-02"))
}

// GeneratePDF creates a PDF report and saves it to outputPath
func GeneratePDF(report *ReportData, outputPath string, version string) error {
	if report == nil {
		return fmt.Errorf("report data is nil")
	}
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create PDF output directory: %w", err)
	}

	pdf := fpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(pdfMarginLeft, pdfMarginTop, pdfMarginRight)
	pdf.SetAutoPageBreak(true, 20)

	pdf.SetFooterFunc(func() {
		pdf.SetY(-15)
		pdf.SetFont("Helvetica", "I", 8)
		pdf.SetTextColor(128, 128, 128)
		pdf.CellFormat(0, 10, fmt.Sprintf("Page %d - Generated by Scrutiny v%s", pdf.PageNo(), version), "", 0, "C", false, 0, "")
	})

	// Page 1: Summary
	pdf.AddPage()
	writeHeader(pdf, report)
	writeExecutiveSummary(pdf, report)
	writeDeviceTable(pdf, report)

	if len(report.ZFSPools) > 0 {
		writeZFSSection(pdf, report)
	}

	// Detail pages for devices with issues
	for i := range report.Devices {
		device := &report.Devices[i]
		if len(device.ActiveFailures) > 0 || len(device.NewAlerts) > 0 {
			pdf.AddPage()
			writeDeviceDetail(pdf, device)
		}
	}

	return pdf.OutputFileAndClose(outputPath)
}

func writeHeader(pdf *fpdf.Fpdf, report *ReportData) {
	periodLabel := capitalizePeriod(report.PeriodType)

	pdf.SetFont("Helvetica", "B", 20)
	pdf.SetTextColor(33, 37, 41)
	pdf.CellFormat(0, 12, "Scrutiny Health Report", "", 1, "L", false, 0, "")

	pdf.SetFont("Helvetica", "", 11)
	pdf.SetTextColor(100, 100, 100)
	pdf.CellFormat(0, 7, fmt.Sprintf("%s Report | %s to %s",
		periodLabel,
		report.PeriodStart.Format("Jan 2, 2006"),
		report.PeriodEnd.Format("Jan 2, 2006")), "", 1, "L", false, 0, "")
	pdf.CellFormat(0, 7, fmt.Sprintf("Generated: %s", report.GeneratedAt.Format("Jan 2, 2006 15:04 MST")), "", 1, "L", false, 0, "")

	pdf.Ln(5)
	pdf.SetDrawColor(200, 200, 200)
	pdf.Line(pdfMarginLeft, pdf.GetY(), pdfPageWidth-pdfMarginRight, pdf.GetY())
	pdf.Ln(5)
}

func writeExecutiveSummary(pdf *fpdf.Fpdf, report *ReportData) {
	pdf.SetFont("Helvetica", "B", 14)
	pdf.SetTextColor(33, 37, 41)
	pdf.CellFormat(0, 10, "Summary", "", 1, "L", false, 0, "")

	status := report.OverallStatus()
	pdf.SetFont("Helvetica", "B", 12)
	switch status {
	case "healthy":
		pdf.SetTextColor(40, 167, 69)
	case "warning":
		pdf.SetTextColor(255, 193, 7)
	case "critical":
		pdf.SetTextColor(220, 53, 69)
	}
	pdf.CellFormat(0, 8, fmt.Sprintf("Overall Status: %s", strings.ToUpper(status)), "", 1, "L", false, 0, "")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(33, 37, 41)
	colW := pdfContentWidth / 4
	pdf.CellFormat(colW, 7, fmt.Sprintf("Total: %d", report.TotalDevices), "", 0, "L", false, 0, "")
	pdf.CellFormat(colW, 7, fmt.Sprintf("Passed: %d", report.PassedDevices), "", 0, "L", false, 0, "")
	pdf.CellFormat(colW, 7, fmt.Sprintf("Warning: %d", report.WarningDevices), "", 0, "L", false, 0, "")
	pdf.CellFormat(colW, 7, fmt.Sprintf("Failed: %d", report.FailedDevices), "", 1, "L", false, 0, "")
	pdf.Ln(5)
}

func writeDeviceTable(pdf *fpdf.Fpdf, report *ReportData) {
	if len(report.Devices) == 0 {
		return
	}

	pdf.SetFont("Helvetica", "B", 14)
	pdf.SetTextColor(33, 37, 41)
	pdf.CellFormat(0, 10, "Devices", "", 1, "L", false, 0, "")

	colWidths := []float64{45, 25, 20, 20, 20, 25, 25}
	headers := []string{"Name", "Status", "Temp (C)", "Min", "Max", "Power-On (h)", "Alerts"}

	pdf.SetFont("Helvetica", "B", 8)
	pdf.SetFillColor(240, 240, 240)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	pdf.SetFont("Helvetica", "", 8)
	for _, d := range report.Devices {
		if d.Status > 0 {
			pdf.SetTextColor(220, 53, 69)
		} else {
			pdf.SetTextColor(33, 37, 41)
		}

		name := d.DisplayName()
		if len(name) > 22 {
			name = name[:22] + "..."
		}

		pdf.CellFormat(colWidths[0], 6, name, "1", 0, "L", false, 0, "")
		pdf.CellFormat(colWidths[1], 6, d.StatusString(), "1", 0, "C", false, 0, "")
		pdf.SetTextColor(33, 37, 41)
		pdf.CellFormat(colWidths[2], 6, fmt.Sprintf("%d", d.TempCurrent), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[3], 6, fmt.Sprintf("%d", d.TempMin), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[4], 6, fmt.Sprintf("%d", d.TempMax), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[5], 6, fmt.Sprintf("%d", d.PowerOnHours), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[6], 6, fmt.Sprintf("%d", len(d.ActiveFailures)+len(d.NewAlerts)), "1", 0, "C", false, 0, "")
		pdf.Ln(-1)
	}
	pdf.Ln(5)
}

func writeZFSSection(pdf *fpdf.Fpdf, report *ReportData) {
	pdf.SetFont("Helvetica", "B", 14)
	pdf.SetTextColor(33, 37, 41)
	pdf.CellFormat(0, 10, "ZFS Pools", "", 1, "L", false, 0, "")

	colWidths := []float64{35, 30, 25, 25, 25, 25}
	headers := []string{"Pool", "Health", "Capacity %", "Read Err", "Write Err", "Cksum Err"}

	pdf.SetFont("Helvetica", "B", 8)
	pdf.SetFillColor(240, 240, 240)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	pdf.SetFont("Helvetica", "", 8)
	for _, pool := range report.ZFSPools {
		if pool.Health != "ONLINE" {
			pdf.SetTextColor(220, 53, 69)
		} else {
			pdf.SetTextColor(33, 37, 41)
		}
		pdf.CellFormat(colWidths[0], 6, pool.Name, "1", 0, "L", false, 0, "")
		pdf.CellFormat(colWidths[1], 6, pool.Health, "1", 0, "C", false, 0, "")
		pdf.SetTextColor(33, 37, 41)
		pdf.CellFormat(colWidths[2], 6, fmt.Sprintf("%.1f", pool.Capacity), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[3], 6, fmt.Sprintf("%d", pool.ErrorsRead), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[4], 6, fmt.Sprintf("%d", pool.ErrorsWrite), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[5], 6, fmt.Sprintf("%d", pool.ErrorsChecksum), "1", 0, "C", false, 0, "")
		pdf.Ln(-1)
	}
	pdf.Ln(5)
}

func writeDeviceDetail(pdf *fpdf.Fpdf, device *DeviceReport) {
	pdf.SetFont("Helvetica", "B", 14)
	pdf.SetTextColor(33, 37, 41)
	pdf.CellFormat(0, 10, fmt.Sprintf("Device: %s", device.DisplayName()), "", 1, "L", false, 0, "")

	pdf.SetFont("Helvetica", "", 9)
	pdf.CellFormat(0, 5, fmt.Sprintf("Model: %s | Serial: %s | Protocol: %s", device.Model, device.Serial, device.Protocol), "", 1, "L", false, 0, "")
	pdf.CellFormat(0, 5, fmt.Sprintf("Status: %s | Power-On Hours: %d | Temperature: %dC (min: %d, max: %d, avg: %.0f)",
		device.StatusString(), device.PowerOnHours, device.TempCurrent, device.TempMin, device.TempMax, device.TempAvg), "", 1, "L", false, 0, "")

	if device.HostID != "" {
		pdf.CellFormat(0, 5, fmt.Sprintf("Host: %s", device.HostID), "", 1, "L", false, 0, "")
	}
	if device.PercentageUsed != nil {
		pdf.CellFormat(0, 5, fmt.Sprintf("NVMe Percentage Used: %d%%", *device.PercentageUsed), "", 1, "L", false, 0, "")
	}
	if device.WearoutValue != nil {
		pdf.CellFormat(0, 5, fmt.Sprintf("SSD Wearout Value: %d", *device.WearoutValue), "", 1, "L", false, 0, "")
	}
	pdf.Ln(3)

	if len(device.ActiveFailures) > 0 {
		pdf.SetFont("Helvetica", "B", 11)
		pdf.CellFormat(0, 8, "Active Failures", "", 1, "L", false, 0, "")
		writeAlertTable(pdf, device.ActiveFailures)
	}

	if len(device.NewAlerts) > 0 {
		pdf.SetFont("Helvetica", "B", 11)
		pdf.CellFormat(0, 8, "New Alerts (this period)", "", 1, "L", false, 0, "")
		writeAlertTable(pdf, device.NewAlerts)
	}

	if device.Performance != nil {
		pdf.SetFont("Helvetica", "B", 11)
		pdf.CellFormat(0, 8, "Performance", "", 1, "L", false, 0, "")
		pdf.SetFont("Helvetica", "", 9)
		pdf.CellFormat(0, 5, fmt.Sprintf("Sequential Read: %.2f MB/s | Sequential Write: %.2f MB/s",
			device.Performance.SeqReadBW/1024/1024, device.Performance.SeqWriteBW/1024/1024), "", 1, "L", false, 0, "")
		pdf.CellFormat(0, 5, fmt.Sprintf("Random Read: %.0f IOPS | Random Write: %.0f IOPS",
			device.Performance.RandReadIOPS, device.Performance.RandWriteIOPS), "", 1, "L", false, 0, "")
		if device.Performance.BaselineDeviation != nil {
			pdf.CellFormat(0, 5, fmt.Sprintf("Baseline Deviation: %.1f%%", *device.Performance.BaselineDeviation), "", 1, "L", false, 0, "")
		}
	}
}

func writeAlertTable(pdf *fpdf.Fpdf, alerts []AlertEntry) {
	colWidths := []float64{30, 50, 25, 25, 25, 25}
	headers := []string{"Attr ID", "Name", "Status", "Value", "Threshold", "Source"}

	pdf.SetFont("Helvetica", "B", 8)
	pdf.SetFillColor(240, 240, 240)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	pdf.SetFont("Helvetica", "", 8)
	for _, alert := range alerts {
		if alert.Status == "failed" {
			pdf.SetTextColor(220, 53, 69)
		} else {
			pdf.SetTextColor(255, 193, 7)
		}
		pdf.CellFormat(colWidths[0], 6, alert.AttributeID, "1", 0, "L", false, 0, "")
		name := alert.AttributeName
		if len(name) > 25 {
			name = name[:25] + "..."
		}
		pdf.CellFormat(colWidths[1], 6, name, "1", 0, "L", false, 0, "")
		pdf.CellFormat(colWidths[2], 6, alert.Status, "1", 0, "C", false, 0, "")
		pdf.SetTextColor(33, 37, 41)
		pdf.CellFormat(colWidths[3], 6, fmt.Sprintf("%d", alert.Value), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[4], 6, fmt.Sprintf("%d", alert.Threshold), "1", 0, "C", false, 0, "")
		pdf.CellFormat(colWidths[5], 6, alert.StatusReason, "1", 0, "C", false, 0, "")
		pdf.Ln(-1)
	}
	pdf.Ln(3)
}
